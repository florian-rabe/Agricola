package rabe.florian.agricola

/** the kind of game, used to check legality of moves */
case class GameType(family: Boolean, moor: Boolean) {
  override def toString = (if (family) "family" else "standard") + (if (moor) " moor" else "")
  def toStringLong = s"Agricola game using ${if (family) "family" else "standard"} version${if (moor) " with Farmers of the Moor expansion" else ""}"
}

/** throw on invalid single-player games */
case class Error(s: String) extends java.lang.Throwable(s)

/** a round in a [[SinglePlayerGame]] */
case class Round(moves: List[Move], afterFieldPhase: List[OtherMove], afterBreeding: List[OtherMove])

/** a game to be fed into [[SinglePlayerGameEvaluator]] */
abstract class SinglePlayerGame(val gameType: GameType) {
  def roundActionSpaces: List[RoundActionSpace]
  def specialActionCards: List[SpecialActionCard]
  def rounds: List[Round]
}

/** reason for a change */
abstract class Cause(s: String) {
  override def toString = s
} 
object FieldPhase extends Cause("harvesting")
object FeedingPhase extends Cause("feeding")
object BreedingPhase extends Cause("breeding")
case class ByImprovement(improvement: Improvement) extends Cause(improvement.toString)
case class ByMove(move: Move) extends Cause(move.toString)

abstract class Event
/** change in player's possession */
case class Change(cause: Cause, amount: Int, token: Token) extends Event {
  def changeString = {
    val plusS = if (amount > 0) "+" else ""
    s"$plusS$amount $token"
  }
  override def toString = s"$cause: ${changeString}"
}
case class BeginMove(move: Move) extends Event
case class EndMove(move: Move) extends Event
case object BeginHarvest extends Event
case object EndHarvest extends Event


/**
 * runs (and validates) a single-player game
 * where the player choose all cards and actions non-interactively
 */
class GameInProgress(val game: SinglePlayerGame, hooks: GameHooks) {
  /** the current round */
  private var round: Int = 0
  /** the rounds after which there is a harvest */
  private val harvestRounds = List(4,7,9,11,13,14)
  /** true if currently in harvest */
  private var inHarvest = false
  /** actions performed during the current harvest */
  private var usedInHarvest: List[OtherMove] = Nil
  /** this is a moor game */
  private val moor = game.gameType.moor

  /**
   * code to be run at the start of each following round
   * will be passed the respective round and the player
   * 
   * e.g., generated by well building
   */
  private var atSoR : List[GameInProgress => Unit] = Nil

  private val p = new Player(game.gameType)
  private val b = new Board(game.gameType)
  
  def board = b
  def player = p
  def currentRound = round
  /** number of new-born family member in the current round */
  def newBorns = b.usedSpaces.count {
    case _:FamilyGrowthAction => true
    case _ => false
  }
  /** number of family member actions left in the current round */
  private def membersLeft = p.member - newBorns - b.usedSpaces.length
  
  protected var logGroupLevel = 0
  protected def log(s: String) {
    val space = Range(0,logGroupLevel).map(_ => " ").mkString("")
    println(space + s)
  }
  protected def logState {
    def doTokenGroup(s: String, tokens: List[(Token, Int)]) {
       log(s + tokens.map{case (t,i) => s"$i $t"}.mkString(": ", ", ", ""))
    }
    val g = game.gameType
    doTokenGroup("Currency", Currency.allowed(g).map(t => (t, p(t))))
    doTokenGroup("Resources", Resource.allowed(g).map(t => (t, p(t))))
    doTokenGroup("Produce", Produce.allowed(g).map(t => (t, p(t))))
    doTokenGroup("Animals", Animal.allowed(g).map(t => (t, p(t))))
    log("  " + checkAnimals.mkString(" ") + s" using ${player.animalKeeping.numFences} fences")
    
    log("Fields: " + p.field.mkString(" "))
  }
  protected def logGroup(code: => Unit) {
    logGroupLevel += 1
    try {
      code
    } finally {
      logGroupLevel -= 1
    }
  } 

  /** checks that n empty spaces are available in the farmyard */
  private def checkEmptySpace(n: Int) {
     val e = p.emptySpaces
     if (e < n) {
       throw Error(s"not enough space: available $e, needed $n")
     }
  }
  /** checks that animals can be accommodated */
  private def checkAnimals = {
     val caps = p.animalKeeping.capacities
     val animals = Animal.all.map(a => CapacityNeeded(p.animal(a),a))
     val alloc = AnimalKeeping.accommodate(caps, animals)
     alloc match {
       case None => 
         throw Error("not enough space for animals")
       case Some(al) =>
        // log(al.mkString(", "))
        al
     }
  }
  
  /** records changes to player */
  private var events: List[Event] = Nil
  /** @return all changes since the previous call */
  def getNewEvents = {
    val es = events
    events = Nil
    es
  }
  def registerEvent(e: Event) {
    events = events ::: List(e)
  }
  /** pays some of a resource (gain if negative) */
  def pay(n: Int, t: Token)(implicit cause: Cause) {
    if (p.tokens(t)<n)
      throw Error("not enough " + t)
    if (!moor && t == Horse) {
      throw Error(s"$t not allowed")
    }
    val verb = if (n > 0) "pay" else "gain"
    if (n != 0) log(s"${verb}ing ${n.abs} $t")
    p.tokens(t) -= n
    if (n != 0)
       registerEvent(Change(cause, -n,t))
  }
  def gain(n: Int, t: Token)(implicit cause: Cause) = pay(-n, t)

  /** plays a game and returns the score */
  def play {
     if (game.roundActionSpaces.length != 14)
       throw Error("wrong number of round action spaces")
     if (moor && game.specialActionCards.length != 10)
       throw Error("wrong number of special action cards")
     game.rounds.foreach {r =>
       round += 1
       // initialize board
       val ras = game.roundActionSpaces(round-1)
       val sac: SpecialActionCard = if (!moor) null else
           if (round > 10) game.specialActionCards.last
           else game.specialActionCards(round-1)
       log("\nRound " + round)
       log("new action space: " + ras)
       if (moor) log("special actions: " + sac.spaces.mkString(", ") + "\n")
       logGroup {
         b.newRound(ras,sac)
         // run hooks
         atSoR.foreach {c => c(this)}
         // take actions
         r.moves foreach {m => makeMoveTop(m)}
         logState
         hooks.afterRound(this)
         if (membersLeft > 0)
           throw Error("members left at end of round")
       }
       // do harvest if necessary
       if (harvestRounds contains round) {
         registerEvent(BeginHarvest)
         harvest(r)
         logState
         registerEvent(EndHarvest)
         hooks.afterHarvest(this)
       } else if (r.afterFieldPhase.nonEmpty || r.afterBreeding.nonEmpty)
         throw Error("not a harvest round")
     }
  }
  
  /** performs a harvest */
  private def harvest(r: Round) {
    inHarvest = true

    // field phase
    log("\nHarvest\n")
    logGroup {
      p.field.foreach {f =>
        f.harvest.foreach {prod =>
          gain(1, prod)(FieldPhase)
        }
      }
      
      // player actions after field phase, e.g., to generate food
      r.afterFieldPhase foreach {m => makeMoveTop(m)}
      
      // feeding
      pay((p.member-newBorns)*3+newBorns, Food)(FeedingPhase)
      
      // heating
      if (moor) {
        val renovHeat = p.hut match {
          case Clay => 1
          case Stone => 2
          case _ => 0
        }
        val furnaceHeat = if (p.improvements contains Furnace) 1 else 0
        val maxHeat = if (p.improvements contains HeatingStove) 1 else 0
        val heat = (p.room - renovHeat - furnaceHeat) max maxHeat
        pay(heat,Fuel)(FeedingPhase)
      }
      
      // breeding
      Animal.all.foreach {a =>
        if (p.animal(a) >= 2) {
          gain(1, a)(BreedingPhase)
        }
      }
      // player actions after breeding, e.g., to generate food
      r.afterBreeding foreach {m => makeMoveTop(m)}
      
      inHarvest = false
      usedInHarvest = Nil
      checkAnimals
    }
  }
  private def makeMoveTop(m: Move) {
    val (p,s) = m match {
      case CompoundMove(p,s) => (p,s)
      case m => (m,Nil)
    }
    log(m.toString)
    registerEvent(BeginMove(m))
    logGroup {
      makeMove(p,s)
    }
    registerEvent(EndMove(m))
  }
  private def makeMove(m: Move, secondary: List[OtherMove]) {
    implicit val cause = ByMove(m)
    if (!m.allowedIn(game.gameType)) {
      throw Error(s"move not allowed in ${game.gameType} game")
    }
    var ovenBuilt = false
    def improve(imp: Improvement) {
       b.build(imp)
       imp._upgradedFrom match {
         case None =>
          // pay with resources
          val (rw,rc,rr,rs) = if (p.improvements contains MuseumOfTheMoor)
            MuseumOfTheMoor.reduction(imp)
          else
            (0,0,0,0)
          val cost = List(imp.wood-rw,imp.clay-rc,imp.reed-rr,imp.stone-rs)
          (cost zip List(Wood,Clay,Reed,Stone)).foreach {
            case (n,res) => if (n != 0) pay(n,res)
          }
         case Some(i) =>
           // pay by upgrade
           if (! (imp.mayUpgrade contains i))
             throw Error(s"cannot upgrade $i to $imp")
           p.improvements = p.improvements.filterNot(_ == i)
           b.unbuild(i)
       }
       p.improvements ::= imp
       imp.onBuild(this)
       atSoR ::= imp.onStartOfRound(round)
       imp match {
         case _: Oven => ovenBuilt = true
         case _ =>
       }
    }
    def renovate {
      p.hut match {
        case Stone => throw Error("already stone")
        case Wood => p.hut = Clay
        case Clay => p.hut = Stone
        case Reed => // impossible 
      }
      pay(p.room, p.hut)
      pay(1, Reed)      
    }
    def fence(f: Fencing) {
       val newFences = f.pastures.numFences-p.animalKeeping.numFences
       pay(newFences, Wood)
       p.animalKeeping.addFences(f.pastures)
       //checking this before would be more elegant but trickier
       //because new pastures can cover existing stables
       checkEmptySpace(0)
    }
    def plow {
      checkEmptySpace(1)
      p.field ::= new Field
    }
    def sow(s: Sowing) {
       val emptyFields = p.field.filter(_.empty)
       if (emptyFields.length < s.sow.length)
          throw Error("not enough empty fields")
       s.sow.zipWithIndex.foreach {case (prod,i) =>
          pay(1, prod)
          emptyFields(i).sow(prod)
       }
    }
    def bake(b: Baking) {
      pay(b.bake, Grain)
      val default = (Nil, 1)
      val rates = default :: p.improvements.collect {
        case imp: BakingImp => (imp.limitedBake,imp.unlimitedBake)
      }
      val (limited,unlimited) = rates.unzip match {
        case (l,u) => (l.flatten.sorted.reverse,u.max)
      }
      val usedLimited = limited.filter(_ > unlimited).take(b.bake)
      val usedUnlimited = (b.bake-usedLimited.length) max 0
      val g = usedLimited.sum + usedUnlimited*unlimited
      gain(g, Food)
    }
    def buildStable(position: Square, cost: Int) {
       checkEmptySpace(1)
       pay(cost, Wood)
       p.animalKeeping.addStable(position)
    }
    m match {
      case CompoundMove(p, s) => // impossible
      case a: Action =>
        if (membersLeft <= 0)
          throw Error("not enough family members")
        if (inHarvest)
          throw Error("not allowed during harvest")
        b.useSpace(a.space)
        a match {
           case tr:TakeRes =>
              gain(b.accumulated(tr), tr.resource)
              b.accumulated(tr) = 0
           case ta:TakeAnimal =>
              gain(b.accumulated(ta), ta.animal) 
              b.accumulated(ta) = 0
           case tp:TakeProduce =>
              gain(1, tp.produce)
           case StartingPlayer =>
              if (game.gameType.family) {
                gain(b.accumulated(StartingPlayer), Food)
                b.accumulated(StartingPlayer) = 0
              }
           case Fishing =>
              gain(b.accumulated(Fishing), Food)
              b.accumulated(Fishing) = 0
           case DayLaborer(res) =>
              if (game.gameType.family) {
                gain(1, Food)
                if (res != null) gain(1, res)
              } else {
                gain(2, Food)
              }
           case fg: FamilyGrowthAction =>
              if (p.member >= 5)
                throw Error("already 5 family members")
              if (fg.withRoom && p.member+1 > p.room)
                throw Error("not enough room")
              p.member += 1
           case Plow =>
             plow
           case ps:PlowAndSow =>
             plow
             sow(ps)
           case sb:SowAndBake =>
             sow(sb)
             bake(sb)
           case b:Build =>
               checkEmptySpace(b.rooms)
               pay(5*b.rooms, p.hut)
               pay(2*b.rooms, Reed)
               p.room += b.rooms
               b.stables.map(i => buildStable(i,2))
           case f:Fences =>
             fence(f)
           case bs:BakeAndStable =>
               bake(bs)
               bs.stable.foreach {i => buildStable(i,1)}
           case r:RenovFences =>
             renovate
             fence(r)
           case Improve(imp) =>
             improve(imp)
           case RenovImprovement(impOpt) =>
             renovate
             impOpt foreach improve
        }
      case sa: SpecialAction =>
        if (membersLeft <= 0)
          throw Error("special action requires unused family members")
        if (inHarvest)
          throw Error("not allowed during harvest")
        if (b.sacUsed > 0)
          pay(2,Food)
        b.useSpecialAction(sa)
        sa match {
          case CutPeat =>
            if (p.moor <= 0)
              throw Error("no moor left")
            val bonus = if (p.improvements contains Kiln) {
              if (p.animal(Horse) > 0)
                2
              else 1
            } else 0
            p.moor -= 1
            gain(3+bonus, Fuel)
          case FellTrees =>
            if (p.forest <= 0)
              throw Error("no forest left")
            val bonus = if (p.improvements contains ForestersLodge) {
              if (p.animal(Horse) > 0)
                2
              else 1
            } else 0
            p.forest -= 1
            gain(2+bonus, Wood)
          case SlashAndBurn =>
            if (p.forest <= 0)
              throw Error("no forest left")
            p.forest -= 1
            plow            
          case HorseCoper =>
            if (b.specialActionCards.last.payForHC) pay(1, Food)
            gain(1, Horse)
          case HiringFair =>
            val g = if (b.specialActionCards.last.twoFromHF) 2 else 1
            gain(g, Food)
          case ClandestineWork(imp) =>
            pay(1, Fuel)
            pay(1, Food)
            improve(imp)
        }
      case o: OtherMove =>
        if (o.isInstanceOf[OncePerHarvest]) {
          if (!inHarvest)
            throw Error(o + " only allowed during harvest")
          if (usedInHarvest contains o)
            throw Error("already used in this harvest")
          usedInHarvest ::= o
        }
        o match {
           case Cook(n,c) =>
             val default = c match {
               case _: Animal => 0
               case _: Produce => 1
             }
             val rates = p.improvements.collect {
                  case imp: CookingImp => imp.cook(c)
               }
             val rate = (default :: rates).max
             pay(n, c)
             gain(n*rate, Food)
           case Release(n,a) =>
             pay(n,a)
           case Burn(n) => 
             pay(n, Wood)
             gain(n, Fuel)
           case Convert(imp) =>
             pay(1,imp.convert)
             gain(imp.food, Food)
           case Exchange(imp, from, to) =>
             if (!imp.exchange(from, to))
               throw Error("exchange not allowed")
             pay(1, from)
             gain(1, to)
           case VillageChurchBonus =>
             pay(1,Fuel)
             p.bonus += 1
           case sb: Bake =>
             bake(sb)
      }
    }
    // check legality of secondary moves and recurse for them
    secondary.foreach {sec =>
      val allowed = sec match {
        case c: Cook => true
        case b: Bake => ovenBuilt
        case b: Burn => true
        case e: Exchange => p.improvements contains e.imp
        case c: Convert => p.improvements contains c.imp
        case VillageChurchBonus => p.improvements contains VillageChurch
        case r: Release => true
      }
      if (! allowed)
       throw Error(s"secondary move $sec not allowed")
      makeMove(sec,Nil)
    }
    checkAnimals
  }
}

/** hooks to override, e.g., for logging */
class GameHooks {
  def afterRound(g: GameInProgress) {}
  def afterHarvest(g: GameInProgress) {}
}

object EmptyGameHooks extends GameHooks